# ADR-006: Manual Code Reconciliation (Generation Gap Pattern)

## Status

Accepted

## Context

### Problem

Generated projects rarely stay purely generated:

1. **Manual additions**: Developers add custom code after initial generation
2. **Regeneration risk**: Re-running generator overwrites manual changes
3. **Protected regions fail**: Comment markers are fragile and error-prone
4. **Bidirectional sync**: Changes in generated code should inform the model

Without reconciliation, teams either avoid regeneration entirely or lose manual customizations.

### Research: Round-Trip Engineering Patterns

| Pattern | Description | Pros | Cons |
|---------|-------------|------|------|
| **Protected Regions** | `// BEGIN PROTECTED` markers | Simple | Fragile, easy to corrupt |
| **Generation Gap** | Generated base class, manual subclass | Clean separation | Requires inheritance |
| **Partial Classes** | C# partial keyword | Language native | Language-specific |
| **Bidirectional Sync** | Model ↔ Code synchronization | Full flexibility | Complex, conflict-prone |

The **Generation Gap Pattern** (John Vlissides, Design Patterns) provides the cleanest separation for languages with inheritance.

### Goal

Enable safe regeneration while preserving manual customizations, and detect/import manually-added code into the symbol table.

## Decision

Adopt the **Generation Gap Pattern** for code generation, combined with **Import Detection** for manually-added files.

### Generation Gap Architecture

For each generated component, create TWO files:

```
┌─────────────────────────────────────────────────────────────┐
│                    Generation Strategy                       │
└─────────────────────────────────────────────────────────────┘

For each component, generate TWO files:

  1. ComponentName.generated.ts  (NEVER EDIT - regenerated)
     └── export abstract class ComponentName_Base { ... }

  2. ComponentName.ts  (USER OWNS - created once if missing)
     └── export class ComponentName extends ComponentName_Base { ... }

On regeneration:
  - *.generated.ts → overwritten
  - *.ts → preserved (created only if doesn't exist)
```

### File Naming Convention

```
src/
├── auth/
│   ├── JwtService.generated.ts    # Generated - DO NOT EDIT
│   └── JwtService.ts              # User-owned, extends generated
├── content/
│   ├── BlockRenderer.generated.ts
│   └── BlockRenderer.ts
```

### Generated Base Class

```typescript
// JwtService.generated.ts - AUTO-GENERATED, DO NOT EDIT
// Generated by cyrus-code from auth/jwt/JwtService@1.2.0
// Regenerated: 2024-01-15T10:30:00Z

import type { JwtPayload } from './types.generated.js';

/**
 * @generated
 * @see auth/jwt/JwtService@1.2.0
 */
export abstract class JwtService_Base {
  protected readonly secret: string;

  constructor(secret: string) {
    this.secret = secret;
  }

  /** Sign a payload into a JWT token */
  abstract sign(payload: JwtPayload): Promise<string>;

  /** Verify and decode a JWT token */
  abstract verify(token: string): Promise<JwtPayload>;

  /** Refresh an existing token */
  abstract refresh(token: string): Promise<string>;
}
```

### User-Owned Implementation

```typescript
// JwtService.ts - User implementation, safe from regeneration

import { JwtService_Base } from './JwtService.generated.js';
import { SignJWT, jwtVerify } from 'jose';

export class JwtService extends JwtService_Base {
  // User can add custom fields
  private readonly issuer = 'my-app';

  async sign(payload: JwtPayload): Promise<string> {
    // Custom implementation with user-specific logic
    return new SignJWT(payload)
      .setProtectedHeader({ alg: 'HS256' })
      .setIssuer(this.issuer)
      .setExpirationTime('2h')
      .sign(new TextEncoder().encode(this.secret));
  }

  async verify(token: string): Promise<JwtPayload> {
    const { payload } = await jwtVerify(
      token,
      new TextEncoder().encode(this.secret),
      { issuer: this.issuer }
    );
    return payload as JwtPayload;
  }

  async refresh(token: string): Promise<string> {
    const payload = await this.verify(token);
    return this.sign(payload);
  }

  // User can add custom methods
  async validateClaims(token: string, requiredClaims: string[]): Promise<boolean> {
    const payload = await this.verify(token);
    return requiredClaims.every(claim => claim in payload);
  }
}
```

### Symbol Table Integration

> **Canonical definitions**: See [Symbol Table Schema Specification](../spec/symbol-table-schema.md)

Track symbol origin in the symbol table:

```typescript
interface ComponentSymbol {
  // ... existing fields ...

  // === Origin Tracking ===

  /** How this symbol was created */
  origin: SymbolOrigin;

  /** Generation metadata if origin is 'generated' */
  generationMeta?: GenerationMetadata;
}

type SymbolOrigin =
  | 'generated'   // Created by cyrus-code generator
  | 'manual'      // Hand-authored, imported into registry
  | 'external';   // From external package
```

### Import Detection Flow

For projects with existing manual code:

```
┌─────────────────────────────────────────────────────────────┐
│                    Import Detection Flow                     │
└─────────────────────────────────────────────────────────────┘

1. DETECT: Scan project for files not in symbol table
   └── "Found 3 untracked files: UserService.ts, helpers.ts, types.ts"

2. ANALYZE: Parse untracked files, extract structure
   └── "UserService.ts contains class UserService with 5 methods"

3. SUGGEST: Match against known component patterns
   └── "UserService looks like an L1 Component (service pattern)"

4. PROMPT: Ask user to confirm import
   └── "Import UserService as auth/UserService@1.0.0? [y/n/customize]"

5. REGISTER: Add to symbol table with source='manual'
   └── Symbol tracked, but marked as hand-authored
```

### Import Detection Interface

```typescript
interface ImportDetector {
  /**
   * Scan directory for untracked files.
   */
  scanUntracked(directory: string): Promise<UntrackedFile[]>;

  /**
   * Analyze an untracked file and suggest classification.
   */
  analyze(file: UntrackedFile): Promise<ImportSuggestion>;

  /**
   * Import a file into the symbol table.
   */
  import(file: UntrackedFile, config: ImportConfig): Promise<ComponentSymbol>;
}

interface UntrackedFile {
  path: string;
  language: Language;
  lastModified: Date;
  exports: ExportInfo[];
}

interface ExportInfo {
  name: string;
  kind: 'class' | 'function' | 'type' | 'const';
  hasDefaultExport: boolean;
}

interface ImportSuggestion {
  /** Suggested abstraction level */
  level: AbstractionLevel;

  /** Suggested component kind */
  kind: ComponentKind;

  /** Suggested namespace */
  namespace: string;

  /** Confidence score 0-1 */
  confidence: number;

  /** Why this classification was suggested */
  reasoning: string;

  /** Similar existing symbols */
  similarTo?: string[];
}

interface ImportConfig {
  /** Override suggested namespace */
  namespace?: string;

  /** Override suggested level */
  level?: AbstractionLevel;

  /** Initial version */
  version: SemVer;

  /** Tags to apply */
  tags?: string[];
}
```

### Conflict Detection

When regenerating, detect unexpected modifications:

```typescript
interface ConflictDetector {
  /**
   * Check if generated file was modified.
   */
  checkModified(generatedPath: string): Promise<ConflictResult>;

  /**
   * Get diff between expected and actual content.
   */
  getDiff(generatedPath: string): Promise<DiffResult>;
}

interface ConflictResult {
  hasConflict: boolean;
  expectedHash: string;
  actualHash: string;
  modifiedAt?: Date;
}

interface DiffResult {
  /** Unified diff format */
  diff: string;

  /** Number of lines changed */
  linesChanged: number;

  /** Changed sections */
  hunks: DiffHunk[];
}
```

### CLI Commands

```bash
# Generation with gap pattern
cyrus-code generate --gap          # Generate with _Base classes
cyrus-code generate --overwrite    # Force overwrite (dangerous)

# Import detection
cyrus-code scan                    # Find untracked files
cyrus-code import <file>           # Import file to registry
cyrus-code import --interactive    # Interactive import wizard

# Conflict handling
cyrus-code check                   # Check for modified generated files
cyrus-code diff <symbol-id>        # Show diff of generated file
cyrus-code accept <symbol-id>      # Accept manual changes (update hash)
```

### Configuration

```json
{
  "generation": {
    "pattern": "gap",
    "generatedSuffix": ".generated",
    "preserveManual": true,
    "warnOnModification": true
  },
  "import": {
    "autoDetect": true,
    "excludePatterns": ["*.test.ts", "*.spec.ts", "__tests__/**"],
    "defaultVersion": "1.0.0"
  }
}
```

## Consequences

### Positive

- **Safe regeneration**: Generated code always overwritable
- **Custom extensions**: Users extend without risk
- **Clean separation**: Clear boundary between generated and manual
- **Import flexibility**: Existing code can join the registry
- **Conflict awareness**: Detect when rules are violated

### Negative

- **Two files per component**: More files to manage
- **Inheritance requirement**: Pattern needs inheritance support
- **Learning curve**: Developers must understand the split
- **Boilerplate**: User file may be mostly pass-through

### Mitigations

- **Clear naming**: `.generated.ts` suffix makes boundary obvious
- **Scaffolding**: CLI generates both files initially
- **Documentation**: Each generated file includes explanatory comment
- **IDE support**: Language server understands the pattern

## Alternative: Partial Classes (Future)

For languages with native support (C#, Kotlin), consider partial classes:

```csharp
// JwtService.generated.cs - Generated
public partial class JwtService {
    public abstract string Sign(JwtPayload payload);
}

// JwtService.cs - Manual
public partial class JwtService {
    public override string Sign(JwtPayload payload) {
        // Custom implementation
    }

    // Additional methods
    public bool ValidateClaims(string token) { ... }
}
```

This could be a future enhancement for supported languages.

## References

- [Generation Gap Pattern - Martin Fowler](https://martinfowler.com/dslCatalog/generationGap.html)
- [Round-trip Engineering - Wikipedia](https://en.wikipedia.org/wiki/Round-trip_engineering)
- [Xtext Protected Regions](https://github.com/danieldietrich/xtext-protected-regions)
- [Design Patterns - Gamma et al.](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612)
