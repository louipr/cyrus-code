/**
 * Code Generation Utilities
 *
 * ts-morph helpers for generating TypeScript code.
 * Provides reusable functions for creating AST nodes.
 */

import { Project, SourceFile, ClassDeclaration, Scope } from 'ts-morph';
import { createHash } from 'node:crypto';
import type { GeneratedComponent, GeneratedPort } from './schema.js';

// =============================================================================
// Project Management
// =============================================================================

/**
 * Create a new ts-morph project for code generation.
 */
export function createProject(): Project {
  return new Project({
    useInMemoryFileSystem: true,
    compilerOptions: {
      target: 99, // ESNext
      module: 99, // ESNext
      strict: true,
      esModuleInterop: true,
      declaration: true,
    },
  });
}

/**
 * Create a source file in the project.
 */
export function createSourceFile(
  project: Project,
  filePath: string,
  content?: string
): SourceFile {
  return project.createSourceFile(filePath, content ?? '');
}

// =============================================================================
// Class Generation
// =============================================================================

/**
 * Add the generated file header comment.
 */
export function addGeneratedHeader(
  sourceFile: SourceFile,
  symbolId: string,
  generatedAt: Date
): void {
  sourceFile.insertStatements(0, [
    `/**`,
    ` * @generated`,
    ` * DO NOT EDIT - This file is auto-generated by cyrus-code`,
    ` * Source: ${symbolId}`,
    ` * Generated: ${generatedAt.toISOString()}`,
    ` */`,
    '',
  ]);
}

/**
 * Create an abstract base class for a component.
 */
export function createBaseClass(
  sourceFile: SourceFile,
  component: GeneratedComponent,
  includeComments: boolean
): ClassDeclaration {
  const classDecl = sourceFile.addClass({
    name: component.baseClassName,
    isAbstract: true,
    isExported: true,
  });

  if (includeComments && component.description) {
    classDecl.addJsDoc({
      description: `${component.description}\n\nBase class for ${component.className}. Extend this class to implement the component.`,
    });
  }

  return classDecl;
}

/**
 * Add abstract methods for input ports.
 */
export function addInputPortMethods(
  classDecl: ClassDeclaration,
  ports: GeneratedPort[],
  includeComments: boolean
): void {
  for (const port of ports) {
    const methodName = `on${capitalize(port.name)}`;

    const method = classDecl.addMethod({
      name: methodName,
      isAbstract: true,
      scope: Scope.Public,
      parameters: [{ name: 'data', type: port.typeString }],
      returnType: 'void',
    });

    if (includeComments && port.description) {
      method.addJsDoc({
        description: port.description,
        tags: [
          { tagName: 'param', text: `data - Input data of type ${port.typeString}` },
        ],
      });
    }
  }
}

/**
 * Add protected emit methods for output ports.
 */
export function addOutputPortMethods(
  classDecl: ClassDeclaration,
  ports: GeneratedPort[],
  includeComments: boolean
): void {
  for (const port of ports) {
    const methodName = `emit${capitalize(port.name)}`;

    const method = classDecl.addMethod({
      name: methodName,
      scope: Scope.Protected,
      parameters: [{ name: 'data', type: port.typeString }],
      returnType: 'void',
      // NOTE: These statements are emitted into the generated code, not executed here.
      // The console.log is a placeholder until wiring runtime is implemented.
      statements: [
        `// Wiring: emit to connected ports`,
        `// This will be implemented by the wiring runtime`,
        `console.log('Emitting ${port.name}:', data);`,
      ],
    });

    if (includeComments && port.description) {
      method.addJsDoc({
        description: `Emit data through the ${port.name} port.\n\n${port.description}`,
        tags: [
          { tagName: 'param', text: `data - Output data of type ${port.typeString}` },
        ],
      });
    }
  }
}

// =============================================================================
// User Stub Generation
// =============================================================================

/**
 * Create a user implementation stub.
 */
export function createUserStub(
  sourceFile: SourceFile,
  component: GeneratedComponent,
  generatedFileName: string,
  includeComments: boolean
): ClassDeclaration {
  // Add import for base class
  sourceFile.addImportDeclaration({
    moduleSpecifier: `./${generatedFileName.replace('.ts', '.js')}`,
    namedImports: [component.baseClassName],
  });

  // Add user file header
  sourceFile.insertStatements(0, [
    `/**`,
    ` * ${component.className}`,
    ` *`,
    ` * User implementation of ${component.symbolId}`,
    ` * Extend and customize as needed.`,
    ` */`,
    '',
  ]);

  // Create concrete class
  const classDecl = sourceFile.addClass({
    name: component.className,
    extends: component.baseClassName,
    isExported: true,
  });

  if (includeComments && component.description) {
    classDecl.addJsDoc({
      description: component.description,
    });
  }

  // Add stub implementations for input ports
  for (const port of component.inputPorts) {
    const methodName = `on${capitalize(port.name)}`;

    classDecl.addMethod({
      name: methodName,
      scope: Scope.Public,
      parameters: [{ name: 'data', type: port.typeString }],
      returnType: 'void',
      statements: [
        `// TODO: Implement ${methodName}`,
        `throw new Error('Not implemented: ${methodName}');`,
      ],
    });
  }

  return classDecl;
}

// =============================================================================
// Utility Functions
// =============================================================================

/**
 * Capitalize the first letter of a string.
 */
export function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Convert a namespace path to a directory path.
 */
export function namespaceToPath(namespace: string): string {
  return namespace.replace(/\//g, '/');
}

/**
 * Generate a content hash for change detection.
 */
export function generateContentHash(content: string): string {
  return createHash('sha256').update(content).digest('hex').slice(0, 16);
}

/**
 * Format source file with consistent style.
 */
export function formatSourceFile(sourceFile: SourceFile): string {
  sourceFile.formatText({
    indentSize: 2,
    convertTabsToSpaces: true,
    ensureNewLineAtEndOfFile: true,
  });
  return sourceFile.getFullText();
}

// =============================================================================
// Type Resolution
// =============================================================================

